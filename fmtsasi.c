#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>

#define RESV_SECS 12

char idat[RESV_SECS * 128] = {
0xC3, 0x80, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* end 256 bytes */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
/* end 512 bytes */
0xC3, 0x85, 0x24, 0x00, 0x00, 0x3B, 0x3B, 0xD1, 0x21, 0xF0, 0x25, 0xC1, 0x79, 0xFE, 0xC3, 0x28,
0x03, 0x77, 0x78, 0xB7, 0x31, 0x80, 0x26, 0xD5, 0xC0, 0x3A, 0x34, 0x20, 0xFE, 0x05, 0x30, 0x04,
0xD6, 0x03, 0x18, 0x02, 0xD6, 0xA8, 0xE6, 0x03, 0x0F, 0x0F, 0x0F, 0x32, 0xEA, 0x25, 0x3A, 0x8D,
0x22, 0x32, 0xE9, 0x25, 0x3A, 0x91, 0x22, 0x32, 0xED, 0x25, 0x3A, 0x50, 0x21, 0x4F, 0x0C, 0xCD,
0x6C, 0x25, 0xCD, 0x8D, 0x25, 0xCD, 0xCB, 0x25, 0x3A, 0x83, 0x22, 0xE6, 0xE0, 0xC2, 0xE9, 0x24,
0x0C, 0x3E, 0x0C, 0x32, 0xE9, 0x25, 0xCD, 0x6C, 0x25, 0xCD, 0x8D, 0x25, 0x21, 0x85, 0x22, 0x06,
0x08, 0x1E, 0xC8, 0xCD, 0x95, 0x25, 0xCD, 0xCB, 0x25, 0x21, 0xF0, 0x25, 0x7E, 0xB7, 0x28, 0x07,
0xD6, 0x30, 0x21, 0x93, 0x22, 0xBE, 0xD0, 0x21, 0x94, 0x22, 0x4F, 0x06, 0x00, 0x09, 0x09, 0x09,
0xE5, 0x21, 0x9A, 0x22, 0x11, 0x15, 0x00, 0x19, 0x0D, 0xF2, 0x07, 0x25, 0x11, 0x0F, 0x00, 0x19,
0x7E, 0xE1, 0x4E, 0x23, 0x5E, 0x23, 0x56, 0xE6, 0x03, 0x47, 0x32, 0x83, 0x24, 0x28, 0x13, 0x79,
0xE6, 0x1F, 0x4F, 0x3E, 0x01, 0xCB, 0x19, 0xCB, 0x1B, 0xCB, 0x1A, 0x07, 0xB7, 0x10, 0xF6, 0x32,
0x84, 0x24, 0x3A, 0xEA, 0x25, 0xB1, 0x32, 0xEA, 0x25, 0xED, 0x53, 0xEB, 0x25, 0x3E, 0x01, 0x32,
0xED, 0x25, 0x3A, 0x84, 0x22, 0x32, 0xEE, 0x25, 0x3E, 0x08, 0x32, 0xE9, 0x25, 0x3A, 0x50, 0x21,
0x4F, 0x0C, 0xCD, 0x6C, 0x25, 0xCD, 0x8D, 0x25, 0xCD, 0xAE, 0x25, 0xCD, 0xCB, 0x25, 0x21, 0xEA,
0x25, 0x11, 0x77, 0x23, 0x01, 0x05, 0x00, 0xED, 0xB0, 0xC3, 0x80, 0x22, 0x06, 0x00, 0xED, 0x78,
0xE6, 0x08, 0x28, 0x04, 0x10, 0xF8, 0x18, 0x34, 0x3E, 0x40, 0xED, 0x79, 0x06, 0x00, 0xED, 0x78,
0xE6, 0x08, 0x20, 0x04, 0x10, 0xF8, 0x18, 0x24, 0x3E, 0x00, 0xED, 0x79, 0xC9, 0x0D, 0x21, 0xE9,
/* end 768 bytes */
0x25, 0x06, 0x06, 0x1E, 0xD8, 0xC5, 0x0C, 0x06, 0x10, 0xED, 0x78, 0xE6, 0xD8, 0xBB, 0x28, 0x05,
0x10, 0xF7, 0xC1, 0x18, 0x07, 0xC1, 0xED, 0xA3, 0xC2, 0x95, 0x25, 0xC9, 0xD1, 0xC9, 0x21, 0x80,
0x22, 0x0C, 0xED, 0x78, 0x0D, 0xE6, 0xD8, 0xFE, 0x98, 0xC8, 0xE6, 0x98, 0xFE, 0x88, 0x20, 0xF1,
0x3A, 0x84, 0x24, 0x06, 0x80, 0xED, 0xB2, 0x3D, 0x20, 0xF9, 0xC9, 0x21, 0xEF, 0x25, 0x18, 0x03,
0xED, 0x78, 0x77, 0x0C, 0xED, 0x78, 0x0D, 0xE6, 0xF0, 0xFE, 0x90, 0x28, 0xF3, 0xFE, 0xB0, 0x20,
0xF2, 0xED, 0x78, 0x7E, 0xE6, 0x03, 0x20, 0xC4, 0xC9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00
/* fill to 1024 bytes */
};


enum DriveType {
	INVALID = 0,
	// TODO: fix this: controllers vs. drives...
        XEBEC_ST506,	//  5.3MB (XEBEC ctrlr + Seagate ST506 drive)
        XEBEC_ST412,	// 10.6MB
	XEBEC_CM5206,	//  4.4MB
	XEBEC_CM5410,	//  8.9MB
	XEBEC_CM5616,	// 13.3MB
	XEBEC_RO201,	//  5.5MB
	XEBEC_RO202,	// 11.1MB
	XEBEC_RO203,	// 16.7MB
	XEBEC_RO204,	// 22.3MB
	other_other,	// not supported
	NUM_DRV_TYPE
};

int params[NUM_DRV_TYPE][4] = {
[XEBEC_ST506] =  { 153, 4, 128,  64 },
[XEBEC_ST412] =  { 306, 4, 128,  64 },
[XEBEC_CM5206] = { 256, 2, 256, 256 },
[XEBEC_CM5410] = { 256, 4, 256, 256 },
[XEBEC_CM5616] = { 256, 6, 256, 256 },
[XEBEC_RO201] =  { 321, 2, 132,   0 },
[XEBEC_RO202] =  { 321, 4, 132,   0 },
[XEBEC_RO203] =  { 321, 6, 132,   0 },
[XEBEC_RO204] =  { 321, 8, 132,   0 },
};

void setdb(char *buf, int db) {
	buf[0] = db & 0x0ff;
}

void setdw(char *buf, int dw) {
	// little-endian
	buf[0] = dw & 0x0ff;
	buf[1] = (dw >> 8) & 0x0ff;
}

void setd2(char *buf, int dw) {
	// big-endian
	buf[0] = (dw >> 8) & 0x0ff;
	buf[1] = dw & 0x0ff;
}

void setdchars(char *buf, enum DriveType disk) {
	setd2(buf + 0, params[disk][0]);
	setdb(buf + 2, params[disk][1]);
	setd2(buf + 3, params[disk][2]);
	setd2(buf + 5, params[disk][3]);
	buf[7] = 0; // ECC burst length - not relavent
}

void setpart(char *buf, int pstart) {
	// big-endian
	buf[0] = (pstart >> 16) & 0x0ff;
	buf[1] = (pstart >> 8) & 0x0ff;
	buf[2] = pstart & 0x0ff;
}

struct geometry {
	enum DriveType disk;
	int bsh; // hint... minimum
	int spt;
	int ssz;
	int cyls;
	int hds;
	int resv_trks;
	int resv_secs;
	int lat;
	int capacity;
	float factor; // padding for directory
};

void setcpmdpb(char *buf, int psize, struct geometry *geom) {
	int cpmsecs = (psize * geom->ssz);
	cpmsecs /= 128;
	cpmsecs -= geom->resv_trks * 64;
	int bsh, bsm, exm, dsm, drm, alv0, dxf;
	double siz = psize * geom->ssz;
	siz /= 1024;
	siz /= 1024;

	for (bsh = geom->bsh; bsh <= 8; ++bsh) {
		bsm = (1 << bsh) - 1;
		dsm = cpmsecs >> bsh;
		if (dsm - 1 < 65536) {
			// TODO: could try for 0x100, but...
			if (dsm - 1 >= 256) {
				if (bsh < 4) {
					continue;
				}
				dxf = 2;
				exm = (1 << (bsh - 4)) - 1;
			} else {
				dxf = 1;
				exm = (1 << (bsh - 3)) - 1;
			}
			// now figure number of DIRENTs...
			drm = (dsm / (16 / dxf));
			drm = (drm * geom->factor);
			// TODO pad some extra DIRENTs...
			int x = (drm + 3) / 4; // num of CP/M sectors required for dir
			x = (x + bsm) >> bsh; // num alloc blocks required for dir
			if (x > 16) {
				// can't represent this directory solution in ALV0
				continue;
			}
			alv0 = ~(0x0ffff >> x);
			drm = (x << bsh) * 4;
			break;
		}
	}
	// error check...
	if (bsh > 8) {
		fprintf(stderr, "No suitable BSH found for capacity %d\n", psize);
		return;
	}
	fprintf(stderr, "Using DPB for partition %d = %gMB:\n"
			"        %d\n"
			"        %d,%d,%d\n"
			"        %d-1, %d-1\n"
			"        %02x, %02x\n"
			"        %d,%d\n",
			cpmsecs, siz,
			64, bsh, bsm, exm, dsm, drm,
			(alv0 >> 8) & 0x0ff, alv0 & 0x0ff, 0, geom->resv_trks);
	setdw(buf + 0, 64);  // SPT - constant, regardless of hardware.
	setdb(buf + 2, bsh);
	setdb(buf + 3, bsm);
	setdb(buf + 4, exm);
	setdw(buf + 5, dsm - 1);
	setdw(buf + 7, drm - 1);
	setdb(buf + 9, alv0 >> 8); // essentially big-endian...
	setdb(buf + 10, alv0);     //
	setdw(buf + 11, 0);	// fixed media, no CKS
	setdw(buf + 13, geom->resv_trks);
	// non-CP/M:
	setdb(buf + 15, 0b00000010);
	setdb(buf + 16, 0b10000000);
	setdb(buf + 17, 0b00000000);
	setdb(buf + 18, 0b11111111);
	setdb(buf + 19, 0b11111111);
	setdb(buf + 20, 0b11111111);
}

int main(int argc, char **argv) {
	int fd;
	char *buf;
	int c;
	int err = 0;
	struct geometry geom;
	int parts[8];
	int nparts = 0;
	int overwrite = 0;
	int repair = 0;
	int use_rest = 0;

	geom.disk = INVALID;
	geom.ssz = 256;
	geom.lat = 1;
	geom.resv_trks = 2; // each partition, for CP/M...
	geom.resv_secs = RESV_SECS; // per disk, for init data. 128-byte sectors!
	geom.bsh = 3; // minimum value
	geom.factor = 1.0;

	extern char *optarg;
	extern int optind;

	while ((c = getopt(argc, argv, "b:f:l:oOp:")) != EOF) {
		switch(c) {
		case 'b':
			geom.bsh = strtoul(optarg, NULL, 0);
			break;
		case 'f':
			geom.factor = strtof(optarg, NULL);
			if (geom.factor < 1.0) {
				geom.factor = 1.0;
			}
			break;
		case 'o':
			overwrite = 1;
			break;
		case 'O':
			repair = 1;
			break;
		case 'l':
			geom.lat = strtoul(optarg, NULL, 0);
			break;
		case 'p':
			if (nparts >= 8) {
				fprintf(stderr, "too many partitions\n");
				exit(1);
			}
			// if "0" then use rest of disk... must be last!
			if (use_rest) {
				fprintf(stderr, "Partition \"rest of disk\" is not last\n");
				exit(1);
			}
			int p = strtoul(optarg, NULL, 0);
			if (p == 0) {
				use_rest = 1;
			}
			parts[nparts++] = p;
			break;
		default:
			break;
		}
	}

	if (argc - optind < 1) {
		fprintf(stderr, "Usage: %s [options] <image> [format-options]\n"
			"Options:\n"
			"    -b bsh  = set minimum BSH for CP/M DPBs\n"
			"    -p size = add partition size <size> sectors\n"
			"              Last may be 0 for reset of disk\n"
			"    -o      = overwrite and existing image\n"
			"    -O      = overwrite only partition info of existing image\n"
			"    -l lat  = describe sector latency layout (unused)\n"
			"format-Options:\n"
			"    XEBEC_ST506 |\n"
			"        XEBEC_ST412 |\n"
			"        XEBEC_CM5206 |\n"
			"        XEBEC_CM5410 |\n"
			"        XEBEC_CM5616 |\n"
			"        XEBEC_RO201 |\n"
			"        XEBEC_RO202 |\n"
			"        XEBEC_RO203 |\n"
			"        XEBEC_RO204\n"
			"    SS\n"
			"Where: SS = Sector Size 512 (default 256)\n"
			"       Partition default is a single partition full disk\n"
			, argv[0]);
		exit(1);
	}
	if (geom.bsh < 3 || geom.bsh > 8) {
		fprintf(stderr, "Invalid value for BSH: %d\n", geom.bsh);
		exit(1);
	}
	char *name = argv[optind];
	for (c = optind + 1; c < argc; ++c) {

		if (strcasecmp(argv[c], "XEBEC_ST506") == 0) {
			geom.disk = XEBEC_ST506;
		} else if (strcasecmp(argv[c], "XEBEC_ST412") == 0) {
			geom.disk = XEBEC_ST412;
		} else if (strcasecmp(argv[c], "XEBEC_CM5206") == 0) {
			geom.disk = XEBEC_CM5206;
		} else if (strcasecmp(argv[c], "XEBEC_CM5410") == 0) {
			geom.disk = XEBEC_CM5410;
		} else if (strcasecmp(argv[c], "XEBEC_CM5616") == 0) {
			geom.disk = XEBEC_CM5616;
		} else if (strcasecmp(argv[c], "XEBEC_RO201") == 0) {
			geom.disk = XEBEC_RO201;
		} else if (strcasecmp(argv[c], "XEBEC_RO202") == 0) {
			geom.disk = XEBEC_RO202;
		} else if (strcasecmp(argv[c], "XEBEC_RO203") == 0) {
			geom.disk = XEBEC_RO203;
		} else if (strcasecmp(argv[c], "XEBEC_RO204") == 0) {
			geom.disk = XEBEC_RO204;
		} else if (strcasecmp(argv[c], "ss") == 0) {
			geom.ssz = 512;
		} else {
			fprintf(stderr, "Unsupported option: %s\n", argv[c]);
			++err;
		}
	}
	if (geom.disk == INVALID) {
		fprintf(stderr, "Must specify a disk/controller combination\n");
		exit(1);
	}
	if (geom.ssz == 512) {
		geom.spt = 17;
	} else {
		geom.spt = 32;
	}
	geom.cyls = params[geom.disk][0];
	geom.hds = params[geom.disk][1];
	geom.capacity = geom.cyls * geom.hds * geom.spt;
	int avail = geom.capacity - geom.resv_secs;
	if (nparts == 0) {
		parts[nparts++] = avail;
	}
	double cap = geom.capacity;
	cap *= geom.ssz;
	cap /= 1024;
	cap /= 1024;
	fprintf(stderr, "Using disk %dx%d (%gMB) in %d partition(s)\n",
			geom.capacity, geom.ssz, cap, nparts);

	// parts[] are in native sectors (geom.ssz), but the CP/M partition
	// table is in CP/M sectors (128-byte sectors)!

	int t = 0, x;
	for (x = 0; x < nparts; ++x) {
		if (parts[x] == 0) {
			parts[x] = avail - t;
		}
		t += parts[x];
		if (t > avail) {
			fprintf(stderr, "Partition %d exceeds available capacity %d\n", x, avail);
			exit(1);
		}
	}
	if (t < avail) {
		fprintf(stderr, "Unused sectors: %d\n", avail - t);
	}

	int flags = O_WRONLY | O_CREAT;
	if (overwrite) {
		flags |= O_TRUNC;
	} else if (!repair) {
		flags |= O_EXCL;
	}
	fd = open(name, flags, 0666);
	if (fd < 0) {
		perror(name);
		exit(1);
	}
	buf = malloc(geom.ssz);
	if (buf == NULL) {
		perror("malloc");
		exit(1);
	}
	if (repair) {
		lseek(fd, (off_t)geom.ssz, SEEK_SET);
	} else {
		snprintf(buf, geom.ssz, "%dc%dh%dz%dp%dl\n",
			geom.cyls, geom.hds, geom.ssz, geom.spt, geom.lat);
		write(fd, buf, geom.ssz);
	}

	int adr = 3;
	memset(idat + adr, 0, 256 - adr);
	idat[adr++] = 0b00011111;	// drive/ctrlr code TODO: discover real codes...
	idat[adr++] = 1;		// control byte
	setdchars(idat + adr, geom.disk); // 8 bytes...
	adr += 8;
	// assign drive type - not used. 6 bytes.
	adr += 6;
	idat[adr++] = nparts;
	t = geom.resv_secs;
	int sxf = geom.ssz / 128;
	for (x = 0; x < 9; ++x) {
		if (x < nparts) {
			fprintf(stderr, "Partition %d start %d\n", x, t);
			setpart(idat + adr, t);
			t += parts[x] * sxf;
		} else {
			setpart(idat + adr, 0);
		}
		adr += 3;
	}
	// +47 bytes. Now CP/M DPBs for each partition...  21 bytes each
	for (x = 0; x < nparts; ++x) {
		setcpmdpb(idat + adr, parts[x], &geom);
		adr += 21;
	}
	write(fd, idat, sizeof(idat));

	if (!repair) {
		memset(buf, 0xe5, geom.ssz);
		for (x = sizeof(idat) / geom.ssz; x < geom.capacity; ++x) {
			write(fd, buf, geom.ssz);
		}
	}

	close(fd);
	return 0;
}
